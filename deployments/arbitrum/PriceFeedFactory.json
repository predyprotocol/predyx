{
  "address": "0x381dA91edB6558D63Af00Dc0436A78BBd051Fb49",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "quotePrice",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "basePrice",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "decimalsDiff",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "priceFeed",
          "type": "address"
        }
      ],
      "name": "PriceFeedCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "quotePrice",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "basePrice",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "decimalsDiff",
          "type": "uint256"
        }
      ],
      "name": "createPriceFeed",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xba2d877137575ec4d6295b79e626a1505911c0e6d169ebcd0673e78b98b3f9e6",
  "receipt": {
    "to": null,
    "from": "0x4f071924D66BBC71A5254217893CC7D49938B1c4",
    "contractAddress": "0x381dA91edB6558D63Af00Dc0436A78BBd051Fb49",
    "transactionIndex": 4,
    "gasUsed": "5040638",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xcfac761bb3ee301c6c099888915c98d978497bbe4f7587452ba0c045ce99420a",
    "transactionHash": "0xba2d877137575ec4d6295b79e626a1505911c0e6d169ebcd0673e78b98b3f9e6",
    "logs": [],
    "blockNumber": 171222702,
    "cumulativeGasUsed": "7858045",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "5bdbb8d21fc18e3c1253724388bc7a46",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quotePrice\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"basePrice\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimalsDiff\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"}],\"name\":\"PriceFeedCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quotePrice\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"basePrice\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimalsDiff\",\"type\":\"uint256\"}],\"name\":\"createPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/PriceFeed.sol\":\"PriceFeedFactory\"},\"evmVersion\":\"paris\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031373035343631373237353638\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"lib/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"},\"src/PriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {AggregatorV3Interface} from \\\"./vendors/AggregatorV3Interface.sol\\\";\\nimport {Constants} from \\\"./libraries/Constants.sol\\\";\\n\\ncontract PriceFeedFactory {\\n    event PriceFeedCreated(address quotePrice, address basePrice, uint256 decimalsDiff, address priceFeed);\\n\\n    function createPriceFeed(address quotePrice, address basePrice, uint256 decimalsDiff) external returns (address) {\\n        PriceFeed priceFeed = new PriceFeed(quotePrice, basePrice, decimalsDiff);\\n\\n        emit PriceFeedCreated(quotePrice, basePrice, decimalsDiff, address(priceFeed));\\n\\n        return address(priceFeed);\\n    }\\n}\\n\\n/// @title PriceFeed\\n/// @notice The contract provides the square root price of the base token in terms of the quote token\\ncontract PriceFeed {\\n    address private immutable _quotePriceFeed;\\n    address private immutable _basePriceFeed;\\n    uint256 private immutable _decimalsDiff;\\n\\n    constructor(address quotePrice, address basePrice, uint256 decimalsDiff) {\\n        _quotePriceFeed = quotePrice;\\n        _basePriceFeed = basePrice;\\n        _decimalsDiff = decimalsDiff;\\n    }\\n\\n    function getSqrtPrice() external view returns (uint256 sqrtPrice) {\\n        (, int256 quoteAnswer,,,) = AggregatorV3Interface(_quotePriceFeed).latestRoundData();\\n        (, int256 baseAnswer,,,) = AggregatorV3Interface(_basePriceFeed).latestRoundData();\\n\\n        require(quoteAnswer > 0 && baseAnswer > 0);\\n\\n        uint256 price = uint256(baseAnswer) * Constants.Q96 / uint256(quoteAnswer);\\n        price = price * Constants.Q96 / _decimalsDiff;\\n\\n        sqrtPrice = FixedPointMathLib.sqrt(price);\\n    }\\n}\\n\",\"keccak256\":\"0xbcb1d95143a12bf55ac1c2368a4b8b819d9b0cabb51e1d8c51d8636b9ab70b20\",\"license\":\"UNLICENSED\"},\"src/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.17;\\n\\nlibrary Constants {\\n    uint256 internal constant ONE = 1e18;\\n\\n    uint256 internal constant MAX_VAULTS = 18446744073709551616;\\n    uint256 internal constant MAX_PAIRS = 18446744073709551616;\\n\\n    // Margin option\\n    int256 internal constant MIN_MARGIN_AMOUNT = 1e6;\\n\\n    uint256 internal constant MIN_LIQUIDITY = 100;\\n\\n    uint256 internal constant MIN_SQRT_PRICE = 79228162514264337593;\\n    uint256 internal constant MAX_SQRT_PRICE = 79228162514264337593543950336000000000;\\n\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n\\n    // 0.2%\\n    uint256 internal constant BASE_MIN_COLLATERAL_WITH_DEBT = 2000;\\n    // 2.5% scaled by 1e6\\n    uint256 internal constant BASE_LIQ_SLIPPAGE_SQRT_TOLERANCE = 12422;\\n    // 5.0% scaled by 1e6\\n    uint256 internal constant MAX_LIQ_SLIPPAGE_SQRT_TOLERANCE = 24710;\\n    // 2.5% scaled by 1e6\\n    uint256 internal constant SLIPPAGE_SQRT_TOLERANCE = 12422;\\n\\n    // 10%\\n    uint256 internal constant SQUART_KINK_UR = 10 * 1e16;\\n}\\n\",\"keccak256\":\"0xfe6e52affc205dd2b994dfbe96305a0cbaf8131ce999804afa98e9dcb0a4092c\",\"license\":\"agpl-3.0\"},\"src/vendors/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n    function description() external view returns (string memory);\\n    function version() external view returns (uint256);\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0x54e9d9b1c158b4a9991657fbce34f7e71c0378806484799f3645657c6f28a5bc\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506105ec806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063b276e32614610030575b600080fd5b61004361003e366004610134565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b6000808484846040516100719061010b565b6001600160a01b0393841681529290911660208301526040820152606001604051809103906000f0801580156100ab573d6000803e3d6000fd5b50604080516001600160a01b038089168252808816602083015291810186905290821660608201529091507fb0f9011f61df26371e5bf3953727f9fd4072a1f178432bf2a17b7578bd2d68b99060800160405180910390a1949350505050565b6104468061017183390190565b80356001600160a01b038116811461012f57600080fd5b919050565b60008060006060848603121561014957600080fd5b61015284610118565b925061016060208501610118565b915060408401359050925092509256fe60e060405234801561001057600080fd5b5060405161044638038061044683398101604081905261002f91610066565b6001600160a01b03928316608052911660a05260c0526100a2565b80516001600160a01b038116811461006157600080fd5b919050565b60008060006060848603121561007b57600080fd5b6100848461004a565b92506100926020850161004a565b9150604084015190509250925092565b60805160a05160c0516103776100cf60003960006101970152600060d901526000604f01526103776000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806386e6862d14610030575b600080fd5b61003861004a565b60405190815260200160405180910390f35b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156100ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100cf91906102a4565b50505091505060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa158015610135573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061015991906102a4565b50505091505060008213801561016f5750600081135b61017857600080fd5b600082610189600160601b846102f4565b610193919061031f565b90507f00000000000000000000000000000000000000000000000000000000000000006101c4600160601b836102f4565b6101ce919061031f565b90506101d9816101e1565b935050505090565b60b581600160881b81106101fa5760409190911b9060801c5b690100000000000000000081106102165760209190911b9060401c5b65010000000000811061022e5760109190911b9060201c5b630100000081106102445760089190911b9060101c5b62010000010260121c80820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c908190048111900390565b805169ffffffffffffffffffff8116811461029f57600080fd5b919050565b600080600080600060a086880312156102bc57600080fd5b6102c586610285565b94506020860151935060408601519250606086015191506102e860808701610285565b90509295509295909350565b808202811582820484141761031957634e487b7160e01b600052601160045260246000fd5b92915050565b60008261033c57634e487b7160e01b600052601260045260246000fd5b50049056fea264697066735822122003d0500f735d3c4db09db84a75c540d6bc7c7425ab52001ffb6a0baf3568853164736f6c63430008130033a26469706673582212205ead7aea46222a82ad7288880d9ed8621a83de3be483e06cdb04357c12c5f93f64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063b276e32614610030575b600080fd5b61004361003e366004610134565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b6000808484846040516100719061010b565b6001600160a01b0393841681529290911660208301526040820152606001604051809103906000f0801580156100ab573d6000803e3d6000fd5b50604080516001600160a01b038089168252808816602083015291810186905290821660608201529091507fb0f9011f61df26371e5bf3953727f9fd4072a1f178432bf2a17b7578bd2d68b99060800160405180910390a1949350505050565b6104468061017183390190565b80356001600160a01b038116811461012f57600080fd5b919050565b60008060006060848603121561014957600080fd5b61015284610118565b925061016060208501610118565b915060408401359050925092509256fe60e060405234801561001057600080fd5b5060405161044638038061044683398101604081905261002f91610066565b6001600160a01b03928316608052911660a05260c0526100a2565b80516001600160a01b038116811461006157600080fd5b919050565b60008060006060848603121561007b57600080fd5b6100848461004a565b92506100926020850161004a565b9150604084015190509250925092565b60805160a05160c0516103776100cf60003960006101970152600060d901526000604f01526103776000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806386e6862d14610030575b600080fd5b61003861004a565b60405190815260200160405180910390f35b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa1580156100ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100cf91906102a4565b50505091505060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa158015610135573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061015991906102a4565b50505091505060008213801561016f5750600081135b61017857600080fd5b600082610189600160601b846102f4565b610193919061031f565b90507f00000000000000000000000000000000000000000000000000000000000000006101c4600160601b836102f4565b6101ce919061031f565b90506101d9816101e1565b935050505090565b60b581600160881b81106101fa5760409190911b9060801c5b690100000000000000000081106102165760209190911b9060401c5b65010000000000811061022e5760109190911b9060201c5b630100000081106102445760089190911b9060101c5b62010000010260121c80820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c908190048111900390565b805169ffffffffffffffffffff8116811461029f57600080fd5b919050565b600080600080600060a086880312156102bc57600080fd5b6102c586610285565b94506020860151935060408601519250606086015191506102e860808701610285565b90509295509295909350565b808202811582820484141761031957634e487b7160e01b600052601160045260246000fd5b92915050565b60008261033c57634e487b7160e01b600052601260045260246000fd5b50049056fea264697066735822122003d0500f735d3c4db09db84a75c540d6bc7c7425ab52001ffb6a0baf3568853164736f6c63430008130033a26469706673582212205ead7aea46222a82ad7288880d9ed8621a83de3be483e06cdb04357c12c5f93f64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}