{
  "address": "0xbDb43F342Be3722746a9FF0C049b676987C88a4D",
  "abi": [
    {
      "inputs": [],
      "name": "PriceGreaterThanLimit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PriceLessThanLimit",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "market",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "trader",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderInfo",
              "name": "info",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "quoteToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "baseToken",
              "type": "address"
            },
            {
              "internalType": "int256",
              "name": "baseTokenAmount",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "quoteTokenAmount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "validatorAddress",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "validationData",
              "type": "bytes"
            }
          ],
          "internalType": "struct SpotOrder",
          "name": "spotOrder",
          "type": "tuple"
        },
        {
          "internalType": "int256",
          "name": "quoteTokenAmount",
          "type": "int256"
        },
        {
          "internalType": "address",
          "name": "filler",
          "type": "address"
        }
      ],
      "name": "validate",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x4312c2448bb84e7b5d450d84d5fe913f5a2925d238b71fd0d9e75f9a7e17f130",
  "receipt": {
    "to": null,
    "from": "0x4f071924D66BBC71A5254217893CC7D49938B1c4",
    "contractAddress": "0xbDb43F342Be3722746a9FF0C049b676987C88a4D",
    "transactionIndex": 1,
    "gasUsed": "4196199",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x59ff577fd29bc9dbc22230dce7f9119c2cff91366f51bf8baf13444e74a74667",
    "transactionHash": "0x4312c2448bb84e7b5d450d84d5fe913f5a2925d238b71fd0d9e75f9a7e17f130",
    "logs": [],
    "blockNumber": 171222676,
    "cumulativeGasUsed": "4196199",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "5bdbb8d21fc18e3c1253724388bc7a46",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"PriceGreaterThanLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceLessThanLimit\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"baseTokenAmount\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"quoteTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"validatorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"validationData\",\"type\":\"bytes\"}],\"internalType\":\"struct SpotOrder\",\"name\":\"spotOrder\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"quoteTokenAmount\",\"type\":\"int256\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"}],\"name\":\"validate\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"The LimitOrderValidator contract is responsible for validating the limit orders\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/markets/spot/SpotExclusiveLimitOrderValidator.sol\":\"SpotExclusiveLimitOrderValidator\"},\"evmVersion\":\"paris\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031373035343631373237353638\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"lib/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"},\"lib/v3-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7825565a4bb2a34a1dc96bbfead755785dfb0df8ef81bd934c43023689685645\",\"license\":\"MIT\"},\"src/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.17;\\n\\nlibrary Constants {\\n    uint256 internal constant ONE = 1e18;\\n\\n    uint256 internal constant MAX_VAULTS = 18446744073709551616;\\n    uint256 internal constant MAX_PAIRS = 18446744073709551616;\\n\\n    // Margin option\\n    int256 internal constant MIN_MARGIN_AMOUNT = 1e6;\\n\\n    uint256 internal constant MIN_LIQUIDITY = 100;\\n\\n    uint256 internal constant MIN_SQRT_PRICE = 79228162514264337593;\\n    uint256 internal constant MAX_SQRT_PRICE = 79228162514264337593543950336000000000;\\n\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n\\n    // 0.2%\\n    uint256 internal constant BASE_MIN_COLLATERAL_WITH_DEBT = 2000;\\n    // 2.5% scaled by 1e6\\n    uint256 internal constant BASE_LIQ_SLIPPAGE_SQRT_TOLERANCE = 12422;\\n    // 5.0% scaled by 1e6\\n    uint256 internal constant MAX_LIQ_SLIPPAGE_SQRT_TOLERANCE = 24710;\\n    // 2.5% scaled by 1e6\\n    uint256 internal constant SLIPPAGE_SQRT_TOLERANCE = 12422;\\n\\n    // 10%\\n    uint256 internal constant SQUART_KINK_UR = 10 * 1e16;\\n}\\n\",\"keccak256\":\"0xfe6e52affc205dd2b994dfbe96305a0cbaf8131ce999804afa98e9dcb0a4092c\",\"license\":\"agpl-3.0\"},\"src/libraries/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"lib/v3-core/contracts/libraries/FullMath.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {Constants} from \\\"../Constants.sol\\\";\\n\\nlibrary Math {\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? b : a;\\n    }\\n\\n    function fullMulDivInt256(int256 x, uint256 y, uint256 z) internal pure returns (int256) {\\n        if (x == 0) {\\n            return 0;\\n        } else if (x > 0) {\\n            return int256(FullMath.mulDiv(uint256(x), y, z));\\n        } else {\\n            return -int256(FullMath.mulDiv(uint256(-x), y, z));\\n        }\\n    }\\n\\n    function fullMulDivDownInt256(int256 x, uint256 y, uint256 z) internal pure returns (int256) {\\n        if (x == 0) {\\n            return 0;\\n        } else if (x > 0) {\\n            return int256(FullMath.mulDiv(uint256(x), y, z));\\n        } else {\\n            return -int256(FullMath.mulDivRoundingUp(uint256(-x), y, z));\\n        }\\n    }\\n\\n    function mulDivDownInt256(int256 x, uint256 y, uint256 z) internal pure returns (int256) {\\n        if (x == 0) {\\n            return 0;\\n        } else if (x > 0) {\\n            return int256(FixedPointMathLib.mulDivDown(uint256(x), y, z));\\n        } else {\\n            return -int256(FixedPointMathLib.mulDivUp(uint256(-x), y, z));\\n        }\\n    }\\n\\n    function addDelta(uint256 a, int256 b) internal pure returns (uint256) {\\n        if (b >= 0) {\\n            return a + uint256(b);\\n        } else {\\n            return a - uint256(-b);\\n        }\\n    }\\n\\n    function calSqrtPriceToPrice(uint256 sqrtPrice) internal pure returns (uint256 price) {\\n        price = (sqrtPrice * sqrtPrice) >> Constants.RESOLUTION;\\n    }\\n}\\n\",\"keccak256\":\"0x1d4bb898c6ae1528862522cc11e48f0f239c83e6d861609a03e89a77ceac784e\",\"license\":\"agpl-3.0\"},\"src/libraries/orders/OrderInfoLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nstruct OrderInfo {\\n    address market;\\n    address trader;\\n    uint256 nonce;\\n    uint256 deadline;\\n}\\n\\n/// @notice helpers for handling OrderInfo objects\\nlibrary OrderInfoLib {\\n    bytes internal constant ORDER_INFO_TYPE = \\\"OrderInfo(address market,address trader,uint256 nonce,uint256 deadline)\\\";\\n    bytes32 internal constant ORDER_INFO_TYPE_HASH = keccak256(ORDER_INFO_TYPE);\\n\\n    /// @notice hash an OrderInfo object\\n    /// @param info The OrderInfo object to hash\\n    function hash(OrderInfo memory info) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ORDER_INFO_TYPE_HASH, info.market, info.trader, info.nonce, info.deadline));\\n    }\\n}\\n\",\"keccak256\":\"0x39ad592c624aa57ab2c4fc3a169a51fce4950f4711064a82e5615d47135ab946\",\"license\":\"UNLICENSED\"},\"src/libraries/orders/ResolvedOrder.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport {OrderInfo} from \\\"./OrderInfoLib.sol\\\";\\n\\nstruct ResolvedOrder {\\n    OrderInfo info;\\n    address token;\\n    uint256 amount;\\n    bytes32 hash;\\n    bytes sig;\\n}\\n\\nlibrary ResolvedOrderLib {\\n    /// @notice thrown when the order targets a different market contract\\n    error InvalidMarket();\\n\\n    /// @notice thrown if the order has expired\\n    error DeadlinePassed();\\n\\n    /// @notice Validates a resolved order, reverting if invalid\\n    /// @param resolvedOrder resovled order\\n    function validate(ResolvedOrder memory resolvedOrder) internal view {\\n        if (address(this) != address(resolvedOrder.info.market)) {\\n            revert InvalidMarket();\\n        }\\n\\n        if (block.timestamp > resolvedOrder.info.deadline) {\\n            revert DeadlinePassed();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2b4b6ea1de1d2a8852cc7c77e1764811e5605b854cac1b914807c544752bec7c\",\"license\":\"UNLICENSED\"},\"src/markets/spot/SpotExclusiveLimitOrderValidator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport {Constants} from \\\"../../libraries/Constants.sol\\\";\\nimport {Math} from \\\"../../libraries/math/Math.sol\\\";\\nimport {SpotOrder} from \\\"./SpotOrder.sol\\\";\\n\\nstruct SpotExclusiveLimitOrderValidationData {\\n    address filler;\\n    uint256 limitQuoteTokenAmount;\\n}\\n\\n/**\\n * @notice The LimitOrderValidator contract is responsible for validating the limit orders\\n */\\ncontract SpotExclusiveLimitOrderValidator {\\n    error PriceGreaterThanLimit();\\n\\n    error PriceLessThanLimit();\\n\\n    function validate(SpotOrder memory spotOrder, int256 quoteTokenAmount, address filler) external pure {\\n        SpotExclusiveLimitOrderValidationData memory validationData =\\n            abi.decode(spotOrder.validationData, (SpotExclusiveLimitOrderValidationData));\\n\\n        require(validationData.filler == filler);\\n\\n        if (spotOrder.baseTokenAmount != 0) {\\n            if (spotOrder.baseTokenAmount > 0 && validationData.limitQuoteTokenAmount < uint256(-quoteTokenAmount)) {\\n                revert PriceGreaterThanLimit();\\n            }\\n\\n            if (spotOrder.baseTokenAmount < 0 && validationData.limitQuoteTokenAmount > uint256(quoteTokenAmount)) {\\n                revert PriceLessThanLimit();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8f1dfb27336339b4ef44179d45620f80826874cbfd858ade1290a9c75f9b242b\",\"license\":\"UNLICENSED\"},\"src/markets/spot/SpotOrder.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport {OrderInfo, OrderInfoLib} from \\\"../../libraries/orders/OrderInfoLib.sol\\\";\\nimport {ResolvedOrder} from \\\"../../libraries/orders/ResolvedOrder.sol\\\";\\n\\nstruct SpotOrder {\\n    OrderInfo info;\\n    address quoteToken;\\n    address baseToken;\\n    int256 baseTokenAmount;\\n    uint256 quoteTokenAmount;\\n    address validatorAddress;\\n    bytes validationData;\\n}\\n\\n/// @notice helpers for handling predict order objects\\nlibrary SpotOrderLib {\\n    using OrderInfoLib for OrderInfo;\\n\\n    bytes internal constant SPOT_ORDER_TYPE = abi.encodePacked(\\n        \\\"SpotOrder(\\\",\\n        \\\"OrderInfo info,\\\",\\n        \\\"address quoteToken,\\\",\\n        \\\"address baseToken,\\\",\\n        \\\"int256 baseTokenAmount,\\\",\\n        \\\"uint256 quoteTokenAmount,\\\",\\n        \\\"address validatorAddress,\\\",\\n        \\\"bytes validationData)\\\"\\n    );\\n\\n    bytes internal constant ORDER_TYPE = abi.encodePacked(SPOT_ORDER_TYPE, OrderInfoLib.ORDER_INFO_TYPE);\\n    bytes32 internal constant SPOT_ORDER_TYPE_HASH = keccak256(ORDER_TYPE);\\n\\n    string internal constant TOKEN_PERMISSIONS_TYPE = \\\"TokenPermissions(address token,uint256 amount)\\\";\\n\\n    /// @dev Note that sub-structs have to be defined in alphabetical order in the EIP-712 spec\\n    string internal constant PERMIT2_ORDER_TYPE = string(\\n        abi.encodePacked(\\\"SpotOrder witness)\\\", OrderInfoLib.ORDER_INFO_TYPE, SPOT_ORDER_TYPE, TOKEN_PERMISSIONS_TYPE)\\n    );\\n\\n    /// @notice hash the given order\\n    /// @param order the order to hash\\n    /// @return the eip-712 order hash\\n    function hash(SpotOrder memory order) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                SPOT_ORDER_TYPE_HASH,\\n                order.info.hash(),\\n                order.quoteToken,\\n                order.baseToken,\\n                order.baseTokenAmount,\\n                order.quoteTokenAmount,\\n                order.validatorAddress,\\n                keccak256(order.validationData)\\n            )\\n        );\\n    }\\n\\n    function resolve(SpotOrder memory spotOrder, bytes memory sig) internal pure returns (ResolvedOrder memory) {\\n        uint256 amount;\\n        address token;\\n\\n        if (spotOrder.baseTokenAmount > 0) {\\n            token = spotOrder.quoteToken;\\n            amount = spotOrder.quoteTokenAmount;\\n        } else {\\n            token = spotOrder.baseToken;\\n            amount = uint256(-spotOrder.baseTokenAmount);\\n        }\\n\\n        return ResolvedOrder(spotOrder.info, token, amount, hash(spotOrder), sig);\\n    }\\n}\\n\",\"keccak256\":\"0x266f634c38ce1aa95ffe70c9e16cb1ecb8fb3edb1faf35ca6d51440ac2883b69\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061040c806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063a59340f914610030575b600080fd5b61004361003e366004610271565b610045565b005b60008360c0015180602001905181019061005f9190610354565b9050816001600160a01b031681600001516001600160a01b03161461008357600080fd5b6060840151156100ff57600084606001511380156100ac57506100a5836103ac565b8160200151105b156100ca5760405163678487e160e01b815260040160405180910390fd5b600084606001511280156100e15750828160200151115b156100ff5760405163feca548760e01b815260040160405180910390fd5b50505050565b634e487b7160e01b600052604160045260246000fd5b60405160e0810167ffffffffffffffff8111828210171561013e5761013e610105565b60405290565b6001600160a01b038116811461015957600080fd5b50565b803561016781610144565b919050565b60006080828403121561017e57600080fd5b6040516080810181811067ffffffffffffffff821117156101a1576101a1610105565b60405290508082356101b281610144565b815260208301356101c281610144565b8060208301525060408301356040820152606083013560608201525092915050565b600082601f8301126101f557600080fd5b813567ffffffffffffffff8082111561021057610210610105565b604051601f8301601f19908116603f0116810190828211818310171561023857610238610105565b8160405283815286602085880101111561025157600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060006060848603121561028657600080fd5b833567ffffffffffffffff8082111561029e57600080fd5b9085019061014082880312156102b357600080fd5b6102bb61011b565b6102c5888461016c565b81526102d36080840161015c565b60208201526102e460a0840161015c565b604082015260c0830135606082015260e0830135608082015261030a610100840161015c565b60a08201526101208301358281111561032257600080fd5b61032e898286016101e4565b60c083015250945050506020840135915061034b6040850161015c565b90509250925092565b60006040828403121561036657600080fd5b6040516040810181811067ffffffffffffffff8211171561038957610389610105565b604052825161039781610144565b81526020928301519281019290925250919050565b6000600160ff1b82016103cf57634e487b7160e01b600052601160045260246000fd5b506000039056fea2646970667358221220bd460bdd7931cb9256c61402efaa2342517f2c7dbd9166c446a8897bd8bb9e6d64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063a59340f914610030575b600080fd5b61004361003e366004610271565b610045565b005b60008360c0015180602001905181019061005f9190610354565b9050816001600160a01b031681600001516001600160a01b03161461008357600080fd5b6060840151156100ff57600084606001511380156100ac57506100a5836103ac565b8160200151105b156100ca5760405163678487e160e01b815260040160405180910390fd5b600084606001511280156100e15750828160200151115b156100ff5760405163feca548760e01b815260040160405180910390fd5b50505050565b634e487b7160e01b600052604160045260246000fd5b60405160e0810167ffffffffffffffff8111828210171561013e5761013e610105565b60405290565b6001600160a01b038116811461015957600080fd5b50565b803561016781610144565b919050565b60006080828403121561017e57600080fd5b6040516080810181811067ffffffffffffffff821117156101a1576101a1610105565b60405290508082356101b281610144565b815260208301356101c281610144565b8060208301525060408301356040820152606083013560608201525092915050565b600082601f8301126101f557600080fd5b813567ffffffffffffffff8082111561021057610210610105565b604051601f8301601f19908116603f0116810190828211818310171561023857610238610105565b8160405283815286602085880101111561025157600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060006060848603121561028657600080fd5b833567ffffffffffffffff8082111561029e57600080fd5b9085019061014082880312156102b357600080fd5b6102bb61011b565b6102c5888461016c565b81526102d36080840161015c565b60208201526102e460a0840161015c565b604082015260c0830135606082015260e0830135608082015261030a610100840161015c565b60a08201526101208301358281111561032257600080fd5b61032e898286016101e4565b60c083015250945050506020840135915061034b6040850161015c565b90509250925092565b60006040828403121561036657600080fd5b6040516040810181811067ffffffffffffffff8211171561038957610389610105565b604052825161039781610144565b81526020928301519281019290925250919050565b6000600160ff1b82016103cf57634e487b7160e01b600052601160045260246000fd5b506000039056fea2646970667358221220bd460bdd7931cb9256c61402efaa2342517f2c7dbd9166c446a8897bd8bb9e6d64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "The LimitOrderValidator contract is responsible for validating the limit orders",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}